<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>功能大纲摘要</title>
    <link href="/2024/07/15/%E5%8A%9F%E8%83%BD%E5%A4%A7%E7%BA%B2%E6%91%98%E8%A6%81/"/>
    <url>/2024/07/15/%E5%8A%9F%E8%83%BD%E5%A4%A7%E7%BA%B2%E6%91%98%E8%A6%81/</url>
    
    <content type="html"><![CDATA[<h1 id="功能大纲摘要："><a href="#功能大纲摘要：" class="headerlink" title="功能大纲摘要："></a>功能大纲摘要：</h1><h2 id="帮助"><a href="#帮助" class="headerlink" title="帮助"></a>帮助</h2><ul><li>这个是硬件接线图，需要显示一个当前版本的硬件图片</li></ul><h2 id="硬件参数"><a href="#硬件参数" class="headerlink" title="硬件参数"></a>硬件参数</h2><h3 id="实验参数"><a href="#实验参数" class="headerlink" title="实验参数"></a>实验参数</h3><ul><li>提供单位选择：需要显示时以特定的单位状态显示</li><li>小数点选择：不同单位需要独立的小数点位数选择</li><li>开始全部清零：需要在实验开始时选择是否进行当前清零（大致意思应是校准）</li><li>外接按钮连接：进行GPIO按钮，引脚初始化， 与相对应的软按钮相连</li><li>按钮逻辑选择：切换、长按</li></ul><h3 id="设备参数"><a href="#设备参数" class="headerlink" title="设备参数"></a>设备参数</h3><ul><li>电机类型选择： 伺服电机 | 步进电机</li><li>步进频率、加减速： （需要）</li><li>运动正方向选择： 该设备的什么运动方向为运动正方向</li><li>基础属性取反：位移取反、力值取反、变形取反</li><li>变形来源：位移计、大变形、外部编码、激光测距、内部计数</li><li>位移来源：外部编码、内部编码</li><li>力传感器量程：用于配置力传感器最大值</li><li>力值过载保护：超过量程停转</li><li>最大速度保护：最大限速</li><li>语言：设置翻译</li></ul><h3 id="修订时间"><a href="#修订时间" class="headerlink" title="修订时间"></a>修订时间</h3><ul><li>修改单片机内部时间</li></ul><h3 id="PID设置"><a href="#PID设置" class="headerlink" title="PID设置"></a>PID设置</h3><blockquote><p>下面的问题之后再来探索吧！</p></blockquote><ul><li>增益系数</li><li>最大输出</li><li>最小输出</li><li>总增益最大</li><li>机器属性</li><li>自调整倍率</li><li>死区比例</li><li>超前调整量</li><li>力保持接入</li><li>保持上区间</li><li>保持下区间</li><li>保持增量比例</li></ul><h3 id="公司注册"><a href="#公司注册" class="headerlink" title="公司注册"></a>公司注册</h3><ul><li>定义屏幕显示公司名</li><li>定义注册时间和到期时间</li></ul><h2 id="标定"><a href="#标定" class="headerlink" title="标定"></a>标定</h2><h3 id="位移标定"><a href="#位移标定" class="headerlink" title="位移标定"></a>位移标定</h3><h4 id="手动标定"><a href="#手动标定" class="headerlink" title="手动标定"></a>手动标定</h4><ul><li>标定频率：单片机持续发出的频率数</li><li>标定位移：确定目前移动的位移长度</li><li>标定脉冲：讲道理应该是当前发射的脉冲数 <strong>（存在问题）</strong></li><li>运行时间：当前标定运行时间</li><li>当前位移：根据现在现行标准得出的位移</li><li>属性： 脉冲&#x2F;位移  频率&#x2F;速度</li></ul><h4 id="自动标定"><a href="#自动标定" class="headerlink" title="自动标定"></a>自动标定</h4><ul><li>细分：绕一周所需要的脉冲数</li><li>减速比： 配置齿轮来细分上一条的脉冲数</li><li>螺距：绕一圈移动距离</li></ul><h3 id="力值标定"><a href="#力值标定" class="headerlink" title="力值标定"></a>力值标定</h3><ul><li>标定点数：本次标定标定点数</li><li>误差：与前一个标点的误差偏置</li></ul><h3 id="变形标定"><a href="#变形标定" class="headerlink" title="变形标定"></a>变形标定</h3><h4 id="大变形"><a href="#大变形" class="headerlink" title="大变形"></a>大变形</h4><ul><li>接受大变形提供的脉冲数据，剩下状态与手动标定位移相同</li></ul><h4 id="位移计"><a href="#位移计" class="headerlink" title="位移计"></a>位移计</h4><ul><li>选择零点码值 与 现在位移状态</li></ul><h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><h3 id="打印"><a href="#打印" class="headerlink" title="打印"></a>打印</h3><pre><code class="hljs">将目前显示的曲线和表格打印到打印机上</code></pre><h3 id="数据查询"><a href="#数据查询" class="headerlink" title="数据查询"></a>数据查询</h3><pre><code class="hljs">将目前已经在数据库中存在的数据进行查询</code></pre><h3 id="实验参数-1"><a href="#实验参数-1" class="headerlink" title="实验参数"></a>实验参数</h3><h4 id="式样参数"><a href="#式样参数" class="headerlink" title="式样参数"></a>式样参数</h4><ul><li>当一个实验需要使用零件的属性状态时加入</li></ul><h4 id="实验设置"><a href="#实验设置" class="headerlink" title="实验设置"></a>实验设置</h4><ul><li>实验编号：配置当前数据库标头</li><li>加载方式：根据某个数据恒定进行加载</li><li>断裂比较：根据哪个数据参数进行断裂比较[最大值][上一值]</li><li>断裂判断：根据上一项的某个值的百分比进行判断</li><li>实验方式：<ul><li>破坏 ：力值到量程</li><li>定变形：力值到规定变形</li><li>定力值：力值到规定力值</li></ul></li><li>结束复位：是否位移回正</li><li>起控力值：变形介入点</li><li>断裂最小力值：大于该力值才会判断为断裂</li><li>误差力值：零点附近力值归零</li></ul><h4 id="设备设置"><a href="#设备设置" class="headerlink" title="设备设置"></a>设备设置</h4><ul><li>传感器编号：选择以什么传感器进行感知</li><li>起始速度： 变形为空时速度</li><li>返回速度： 返回时速度</li><li>上升速度： 点击上升按钮时的速度</li><li>下降速度： 点击下降按钮时的速度</li><li>横梁加力方向: 选择运动正方向</li></ul><h4 id="结果设置"><a href="#结果设置" class="headerlink" title="结果设置"></a>结果设置</h4><ul><li>选择实验结果进行显示和保存</li></ul><h4 id="试验主界面"><a href="#试验主界面" class="headerlink" title="试验主界面"></a>试验主界面</h4><h5 id="热数据显示"><a href="#热数据显示" class="headerlink" title="热数据显示"></a>热数据显示</h5><p>在试验运行时就可以计算的数据被称为： 热数据</p><h5 id="底层数据显示"><a href="#底层数据显示" class="headerlink" title="底层数据显示"></a>底层数据显示</h5><p>在收到串口传来的单片机底层数据被称为： 底层数据</p><h5 id="当前曲线绘制"><a href="#当前曲线绘制" class="headerlink" title="当前曲线绘制"></a>当前曲线绘制</h5><p>可以为当前底层数据或热数据两两制作曲线窗口</p><h5 id="当前实验组号"><a href="#当前实验组号" class="headerlink" title="当前实验组号"></a>当前实验组号</h5><p>打通数据库和的稻草</p><h5 id="快捷设置试验速度"><a href="#快捷设置试验速度" class="headerlink" title="快捷设置试验速度"></a>快捷设置试验速度</h5><p>可以为当前所有电机速度获取一个相当可观的值 </p><h5 id="实验结果表"><a href="#实验结果表" class="headerlink" title="实验结果表"></a>实验结果表</h5><p>在该实验组中，每个实验结果保存表</p><h5 id="实验控制按钮"><a href="#实验控制按钮" class="headerlink" title="实验控制按钮"></a>实验控制按钮</h5><p>在该实验中，控制按钮矩阵</p>]]></content>
    
    
    
    <tags>
      
      <tag>项目</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式 行为型模式</title>
    <link href="/2024/07/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20%E2%85%A2/"/>
    <url>/2024/07/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20%E2%85%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="设计模式-Ⅲ"><a href="#设计模式-Ⅲ" class="headerlink" title="设计模式 Ⅲ"></a>设计模式 Ⅲ</h1><blockquote><p>设计模式的课程真的是干活越来越少了</p></blockquote><h2 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h2><h3 id="功能："><a href="#功能：" class="headerlink" title="功能："></a><strong>功能：</strong></h3><ul><li>声明对象其状态，允许再运行时更改其状态</li></ul><h3 id="做法："><a href="#做法：" class="headerlink" title="做法："></a><strong>做法：</strong></h3><ul><li>使用一个类，释放一个接口用于更改该类的状态</li></ul><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a><strong>代码：</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">PRO</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">work</span><span class="hljs-params">()</span> </span>&#123;&#125;;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ProA</span> :<span class="hljs-keyword">public</span> PRO&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">work</span><span class="hljs-params">()</span> </span>&#123;&#125;;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ProB</span> :<span class="hljs-keyword">public</span> PRO&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">work</span><span class="hljs-params">()</span> </span>&#123;&#125;;<br>&#125;;<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MAOMAO</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    PRO* pro;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">change_pro</span><span class="hljs-params">(PRO* a)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>-&gt;pro = a;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><blockquote><p>也称<strong>政策模式</strong></p></blockquote><h3 id="功能：-1"><a href="#功能：-1" class="headerlink" title="功能："></a><strong>功能：</strong></h3><ul><li>根据内部的行为状态，自动选择算法执行方法</li></ul><h3 id="做法：-1"><a href="#做法：-1" class="headerlink" title="做法："></a><strong>做法：</strong></h3><ul><li>使用一个类，释放一个接口用于更改该类的状态</li></ul><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><ul><li>与状态模式的区别在于状态改变对象全局的事件规范，而策略模式改变某个方法的事件规范</li></ul><h2 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h2><h3 id="功能：-2"><a href="#功能：-2" class="headerlink" title="功能："></a><strong>功能：</strong></h3><ul><li>为多种处理的方法提供一种请求的方式</li><li>多个处理机制都有机会进行处理该请求</li><li>责任机将多个处理机串联成链，确保请求会在链上传递并一定得到解决</li></ul><h3 id="做法：-2"><a href="#做法：-2" class="headerlink" title="做法："></a><strong>做法：</strong></h3><ul><li>生成一个类，适配代理类的接口， 完善代理类的输入输出</li><li>该类内部定义一份链表，用于完成责任链的功能</li></ul><h2 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h2><h3 id="功能：-3"><a href="#功能：-3" class="headerlink" title="功能："></a><strong>功能：</strong></h3><ul><li>定义算法框架类，将步骤延迟生效到子类中</li><li>子类可以不改变算法结构的情况下修改步骤</li></ul><h3 id="做法：-3"><a href="#做法：-3" class="headerlink" title="做法："></a><strong>做法：</strong></h3><ul><li>生成子类用于重写父类的算法步骤部分</li></ul><h2 id="广播模式"><a href="#广播模式" class="headerlink" title="广播模式"></a>广播模式</h2><blockquote><p>又名 <strong>观察者模式</strong> 或 <strong>发布-订阅模式</strong></p></blockquote><h3 id="功能：-4"><a href="#功能：-4" class="headerlink" title="功能："></a><strong>功能：</strong></h3><ul><li>实现同类多个对象的集中化，资源，事件管理</li></ul><h3 id="做法：-4"><a href="#做法：-4" class="headerlink" title="做法："></a><strong>做法：</strong></h3><ul><li>建立一个数据结构对所有的聆听类进行管辖</li><li>当事件、资源被总类仲裁通过后， 对所有的聆听类进行通知</li></ul><h3 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a><strong>代码：</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">PRO</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">work</span><span class="hljs-params">()</span> </span>&#123;&#125;;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ProA</span> :<span class="hljs-keyword">public</span> PRO&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">work</span><span class="hljs-params">()</span> </span>&#123;&#125;;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ProB</span> :<span class="hljs-keyword">public</span> PRO&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">work</span><span class="hljs-params">()</span> </span>&#123;&#125;;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MAOMAO</span> &#123;<br>    vector&lt;PRO*&gt; all_pro;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add_box</span><span class="hljs-params">(PRO* a)</span> </span>&#123;<br>        all_pro.<span class="hljs-built_in">push_back</span>(a);<br>    &#125;;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">talk_all</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; all_pro.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            all_pro[i]-&gt;<span class="hljs-built_in">work</span>();<br>        &#125;<br>    &#125;;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="注意："><a href="#注意：" class="headerlink" title="注意："></a><strong>注意：</strong></h3><ul><li>存储时使用指针存储，别让隐式类型转移害一辈子😓</li></ul><h2 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h2><h3 id="功能：-5"><a href="#功能：-5" class="headerlink" title="功能："></a><strong>功能：</strong></h3><ul><li>将请求转换为一个包含请求相关的所有信息的独立对象</li><li>能够实现撤销操作</li></ul><h3 id="做法：-5"><a href="#做法：-5" class="headerlink" title="做法："></a><strong>做法：</strong></h3><ul><li>一份解析命令的类，所有的业务逻辑执行需要必须发送命令至解析命令类来执行命令</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>架构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式 结构性模式</title>
    <link href="/2024/07/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20%E2%85%A1/"/>
    <url>/2024/07/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20%E2%85%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="设计模式-Ⅱ"><a href="#设计模式-Ⅱ" class="headerlink" title="设计模式 Ⅱ"></a>设计模式 Ⅱ</h1><blockquote><p>这一部分相比与上一章干货程度就比较少了</p></blockquote><h2 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h2><h3 id="功能："><a href="#功能：" class="headerlink" title="功能："></a><strong>功能：</strong></h3><ul><li>使用一个类对另外一个类进行接管，接管后可以自行扩展其他方法</li></ul><h3 id="做法："><a href="#做法：" class="headerlink" title="做法："></a><strong>做法：</strong></h3><ul><li>使用一个类生成他的子类（装饰器），对子类构造时必须传参其父类</li><li>重写父类的方法，令其与子类的方法对齐</li><li>为子类新添加方法，用于起到装饰作用</li></ul><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a><strong>代码：</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MAOMAO</span> &#123;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">work</span><span class="hljs-params">()</span> </span>&#123;&#125;;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MA</span>:<span class="hljs-keyword">public</span> MAOMAO &#123;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">MA</span>(MAOMAO maomao_n) &#123;<br>        <span class="hljs-keyword">this</span>-&gt;maomao = maomao_n;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">work</span><span class="hljs-params">()</span> </span>&#123;<br>        maomao.<span class="hljs-built_in">work</span>();<br>        <span class="hljs-built_in">new_work</span>();<br>    &#125;;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">new_work</span><span class="hljs-params">()</span></span>&#123;&#125;;<br><br><span class="hljs-keyword">private</span>:<br>    MAOMAO maomao;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><h3 id="功能：-1"><a href="#功能：-1" class="headerlink" title="功能："></a><strong>功能：</strong></h3><ul><li>使用一个类对另外一个类进行接管，接管后可以自行改写使用另一个类方法</li></ul><h3 id="做法：-1"><a href="#做法：-1" class="headerlink" title="做法："></a><strong>做法：</strong></h3><ul><li>适配器类构造时必须传参<em>被适配类</em></li><li>重写适配器类的方法，令其与被适配类对齐</li><li>尽可能使用目标的方式（参数减少&#x2F;参数增加）去对齐子类的方法</li></ul><h3 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a><strong>代码：</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MAOMAO</span> &#123;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">work</span><span class="hljs-params">(<span class="hljs-type">int</span> a , <span class="hljs-type">int</span> b)</span> </span>&#123;&#125;;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MA</span>:<span class="hljs-keyword">public</span> MAOMAO &#123;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">MA</span>(MAOMAO maomao_n) &#123;<br>        <span class="hljs-keyword">this</span>-&gt;maomao = maomao_n;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">work</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span> </span>&#123;<br>        maomao.<span class="hljs-built_in">work</span>(a, <span class="hljs-number">0</span>);<br>    &#125;;<br><br><span class="hljs-keyword">private</span>:<br>    MAOMAO maomao;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><h3 id="功能：-2"><a href="#功能：-2" class="headerlink" title="功能："></a><strong>功能：</strong></h3><ul><li>为其他对象提供一种代理， 以便控制对这个对象的访问</li></ul><h3 id="做法：-2"><a href="#做法：-2" class="headerlink" title="做法："></a><strong>做法：</strong></h3><ul><li>生成一个类，适配代理类的接口， 完善代理类的输入输出</li></ul><h2 id="脚本模式"><a href="#脚本模式" class="headerlink" title="脚本模式"></a>脚本模式</h2><blockquote><p>又名 <strong>外观模式</strong> 或 <strong>办公模式</strong></p></blockquote><h3 id="功能：-3"><a href="#功能：-3" class="headerlink" title="功能："></a><strong>功能：</strong></h3><ul><li>实现一键式部署</li></ul><h3 id="做法：-3"><a href="#做法：-3" class="headerlink" title="做法："></a><strong>做法：</strong></h3><ul><li>建立新类提供高层次集中化接口，使子系统更易用</li></ul><h3 id="代码：-2"><a href="#代码：-2" class="headerlink" title="代码："></a><strong>代码：</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs C++"><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">W_1</span> &#123;<br><span class="hljs-keyword">public</span> :<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">work</span><span class="hljs-params">()</span> </span>&#123;&#125;;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">W_2</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">work</span><span class="hljs-params">()</span> </span>&#123;&#125;;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">W_3</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">work</span><span class="hljs-params">()</span> </span>&#123;&#125;;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MAOMAO</span> &#123;<br>    W_1 * w1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">W_1</span>();<br>    W_2 * w2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">W_2</span>();<br>    W_3 * w3 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">W_3</span>();<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>        w1-&gt;<span class="hljs-built_in">work</span>();<br>        w2-&gt;<span class="hljs-built_in">work</span>();<br>        w3-&gt;<span class="hljs-built_in">work</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="注意："><a href="#注意：" class="headerlink" title="注意："></a><strong>注意：</strong></h3><ul><li>不符合开闭原则， 如果想修改功能， 需要更改脚本代码</li></ul><h2 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h2><h3 id="功能：-4"><a href="#功能：-4" class="headerlink" title="功能："></a><strong>功能：</strong></h3><ul><li>对一种需要大量资源的类进行池化，严格规定资源占用</li></ul><h3 id="做法：-4"><a href="#做法：-4" class="headerlink" title="做法："></a><strong>做法：</strong></h3><ul><li>生成一个工厂类， 用于批准资源的使用</li><li>取用共享资源类需要遍历选择那份共享资源未被使用的</li><li>归还共享资源类需要及时将自身状态更正为空闲</li><li>定义一个共享资源类， 用于进行正常的资源使用</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>架构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式 创造性模式</title>
    <link href="/2024/07/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%85%A0/"/>
    <url>/2024/07/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%85%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><blockquote><p>主要是要开始自己写架构了，我需要一点点的架构经验</p></blockquote><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><h3 id="功能："><a href="#功能：" class="headerlink" title="功能："></a><strong>功能：</strong></h3><ul><li>确保类只有一个实例，自行实例化并且向项目提供该实例</li></ul><h3 id="做法："><a href="#做法：" class="headerlink" title="做法："></a><strong>做法：</strong></h3><ul><li>构造函数私有化</li><li>提供一个公有静态的函数用于返回唯一的单例</li></ul><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a><strong>代码：</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MAOMAO</span> &#123;<br><br><span class="hljs-keyword">public</span> :<br>    <span class="hljs-function"><span class="hljs-type">static</span> MAOMAO* <span class="hljs-title">git_maomao</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (maomao == <span class="hljs-literal">nullptr</span>) &#123;<br>            maomao = <span class="hljs-keyword">new</span> <span class="hljs-built_in">MAOMAO</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> maomao;<br>    &#125;<br><br><span class="hljs-keyword">private</span> :<br>    <span class="hljs-type">static</span> MAOMAO *maomao;<br>    <span class="hljs-built_in">MAOMAO</span>() &#123; &#125;;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="问题："><a href="#问题：" class="headerlink" title="问题："></a><strong>问题：</strong></h3><ol><li>由于该模式会令所有的代码点同时处理同一个类，于是存在一种非常严重的问题：<em>状态重叠</em>  <blockquote><p>解决方案：无法避免， 该设计模式应只用于工具类，无状态类</p></blockquote></li><li>在多线程时，请确保不会重复争夺单例创建权<blockquote><p>解决方案：可以使用复杂的进程锁 或者 在静态变量初始化时中直接实例化此类</p></blockquote></li></ol><h2 id="集中分配-工厂模式"><a href="#集中分配-工厂模式" class="headerlink" title="[集中分配]工厂模式"></a>[集中分配]工厂模式</h2><h3 id="功能：-1"><a href="#功能：-1" class="headerlink" title="功能："></a><strong>功能：</strong></h3><ul><li>使用一个独立的总类根据状态的不同来返回不同的其他类</li></ul><h3 id="做法：-1"><a href="#做法：-1" class="headerlink" title="做法："></a><strong>做法：</strong></h3><ul><li>提供所有平行类的父类，再提供一个控制该父类升级方向的工厂类</li><li>根据构造函数来指导父类升级方向</li></ul><h3 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a><strong>代码：</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">PRO</span>  &#123;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ProA</span> :<span class="hljs-keyword">public</span> PRO &#123;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ProB</span> :<span class="hljs-keyword">public</span> PRO &#123;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MAOMAO</span> &#123;<br><br><span class="hljs-keyword">public</span> :<br><br>    <span class="hljs-built_in">MAOMAO</span>(<span class="hljs-type">char</span> num) &#123;<br>        <span class="hljs-keyword">if</span> (num == <span class="hljs-string">&#x27;A&#x27;</span>) &#123;<br>            pro = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ProB</span>();<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(num == <span class="hljs-string">&#x27;B&#x27;</span>) &#123;<br>            pro = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ProA</span>();<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            pro = <span class="hljs-literal">nullptr</span>;<br>            <span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>;<br>        &#125;<br>    &#125;<br><br>   <span class="hljs-function">PRO* <span class="hljs-title">get_pro</span><span class="hljs-params">()</span></span>&#123;<br>      <span class="hljs-keyword">return</span> pro;<br>   &#125;<br><span class="hljs-keyword">private</span> :<br>    PRO* pro;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="问题：-1"><a href="#问题：-1" class="headerlink" title="问题："></a><strong>问题：</strong></h3><ol><li>不够灵活，如果父类有新的升级方向，则工厂类也需要更改  <blockquote><p>解决方案：无法避免， 该设计模式应仅用于不需要拓展的类，逻辑已经闭环的类使用</p></blockquote></li></ol><h2 id="扩展分配-工厂模式"><a href="#扩展分配-工厂模式" class="headerlink" title="[扩展分配]工厂模式"></a>[扩展分配]工厂模式</h2><h3 id="功能：-2"><a href="#功能：-2" class="headerlink" title="功能："></a><strong>功能：</strong></h3><ul><li>使用一个独立的总类根据状态的不同来返回不同的其他类</li><li>工厂实例化不同其他类需要延伸至工厂子类</li></ul><h3 id="做法：-2"><a href="#做法：-2" class="headerlink" title="做法："></a><strong>做法：</strong></h3><ul><li>提供所有平行类的父类，再提供一个控制该父类升级方向的工厂重抽象类</li><li>该工厂总类将选择方式纯虚函数化，指定必须子类继承完善</li><li>根据工厂子类来控制升级方向</li></ul><h3 id="代码：-2"><a href="#代码：-2" class="headerlink" title="代码："></a><strong>代码：</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">PRO</span> &#123;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ProA</span> :<span class="hljs-keyword">public</span> PRO &#123;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ProB</span> :<span class="hljs-keyword">public</span> PRO &#123;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MAOMAO</span> &#123;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">MAOMAO</span>() &#123;<br>        pro = <span class="hljs-literal">nullptr</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> PRO* <span class="hljs-title">get_pro</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">protected</span> :<br>    PRO* pro;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MA</span> : <span class="hljs-keyword">public</span> MAOMAO &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">MA</span>(<span class="hljs-type">char</span> num) &#123;<br>        pro = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ProA</span>();<br>    &#125;<br>    <span class="hljs-function">PRO* <span class="hljs-title">get_pro</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> pro;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MB</span> : <span class="hljs-keyword">public</span> MAOMAO &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">MB</span>(<span class="hljs-type">char</span> num) &#123;<br>        pro = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ProB</span>();<br>    &#125;<br>    <span class="hljs-function">PRO* <span class="hljs-title">get_pro</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> pro;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="扩展："><a href="#扩展：" class="headerlink" title="扩展："></a><strong>扩展：</strong></h3><ul><li>工厂也可以成为产品，如果为工厂套接一个超级工厂用于生产工厂，则可以实现一些很匪夷所思的事情</li></ul><h2 id="生成器模式"><a href="#生成器模式" class="headerlink" title="生成器模式"></a>生成器模式</h2><blockquote><p>又称<strong>建造者模式</strong></p></blockquote><h3 id="功能：-3"><a href="#功能：-3" class="headerlink" title="功能："></a><strong>功能：</strong></h3><ul><li>使用一个类中类用于解决构造函数太冗余的问题</li></ul><h3 id="做法：-3"><a href="#做法：-3" class="headerlink" title="做法："></a><strong>做法：</strong></h3><ul><li>提供一系列返回值是本类的工造子类方法</li><li>链式调用，即可实现类的初始化</li></ul><h2 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h2><h3 id="功能：-4"><a href="#功能：-4" class="headerlink" title="功能："></a><strong>功能：</strong></h3><ul><li>用于解决需要完全克隆类的问题</li></ul><h3 id="做法：-4"><a href="#做法：-4" class="headerlink" title="做法："></a><strong>做法：</strong></h3><ul><li>提供一个父类为接口，需要实现克隆功能的对象都需要重写该功能</li><li>重写该功能用于实现克隆功能</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>架构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>QT 计时器功能</title>
    <link href="/2024/07/10/QT%20Timer/"/>
    <url>/2024/07/10/QT%20Timer/</url>
    
    <content type="html"><![CDATA[<h1 id="计时器实现方式"><a href="#计时器实现方式" class="headerlink" title="计时器实现方式"></a>计时器实现方式</h1><br><h2 id="QBasicTimer-类"><a href="#QBasicTimer-类" class="headerlink" title="QBasicTimer 类"></a>QBasicTimer 类</h2><blockquote><p>提供计时器事件，但是十分低级</p></blockquote><h2 id="QObject-类"><a href="#QObject-类" class="headerlink" title="QObject 类"></a>QObject 类</h2><blockquote><p>QObject内部事件，使用StartTimer开启计时器，定时器会在一定的间隔事件后触发timerEvern事件</p></blockquote><h2 id="QTimer-类"><a href="#QTimer-类" class="headerlink" title="QTimer 类"></a>QTimer 类</h2><blockquote><p>提供最丰富的重复、单次定时器功能，提供timerout()信号，可以连接对应槽，使用start() 开启定时器</p></blockquote><p>注意事项：</p><ul><li>分辨率取决于底层操作系统和硬件，据大多数平台支持精度为1ms</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>QT</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>QT 多线程</title>
    <link href="/2024/07/10/QT%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <url>/2024/07/10/QT%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="QT多线程"><a href="#QT多线程" class="headerlink" title="QT多线程"></a>QT多线程</h1><br><h2 id="方式Ⅰ"><a href="#方式Ⅰ" class="headerlink" title="方式Ⅰ"></a>方式Ⅰ</h2><p>继承 QThread 类 ，重构其run函数</p><blockquote><p>该run()独立于主线程存在，成为一个单独进程执行<br>技巧：结束后可以发射一个信号通报别的槽线程执行结束</p></blockquote><p>使用方法：</p><ul><li>.start() 方法运行</li><li>.quit() 线程终止</li><li>wait() 线程运行完毕后结束</li></ul><h2 id="方式Ⅱ"><a href="#方式Ⅱ" class="headerlink" title="方式Ⅱ"></a>方式Ⅱ</h2><p>继承QObject 类 ， 类中设置一位线程函数;<br>需要声明一个QTherad，将自定义类.movetoThread(QTherad)中</p><blockquote><p>这种方法的大致意思就是当执行该类时，所使用的线程被列为子线程，需要在外使用信号槽函数将其和外部连接。</p></blockquote><h1 id="上表总结"><a href="#上表总结" class="headerlink" title="上表总结"></a>上表总结</h1><p>大宗循环线程使用继承QThread类；<br>小量处理线程使用自定义QObject类；</p>]]></content>
    
    
    
    <tags>
      
      <tag>QT</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Qt-Arm项目梳理Ⅰ Main函数</title>
    <link href="/2024/07/01/Qt-arm%E9%A1%B9%E7%9B%AE%E6%A2%B3%E7%90%86%E2%85%A0/"/>
    <url>/2024/07/01/Qt-arm%E9%A1%B9%E7%9B%AE%E6%A2%B3%E7%90%86%E2%85%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="进行一个很快的框架梳理"><a href="#进行一个很快的框架梳理" class="headerlink" title="进行一个很快的框架梳理"></a>进行一个很快的框架梳理</h1><blockquote><p>所以架构师赚钱多（确信</p></blockquote><ul><li>它使用的一个单独的类管理界面的跳转，我在考虑是否Pc端的软件也需要实现这个转变？</li></ul><h2 id="Beep蜂鸣器线程"><a href="#Beep蜂鸣器线程" class="headerlink" title="Beep蜂鸣器线程"></a>Beep蜂鸣器线程</h2><blockquote><p>他把这个控件单独列出来了， 因为他复制的CSDN的😀，这个部分特别公式化和模块化，唯一美中不足就是构造函数没有<strong>私有化</strong>，存在泄露问题</p></blockquote><p>这属于第一次接触Qt中的多进程，多进程是需要使用继承Thread类 ，重写其中run函数来控制的</p><p>自定义的类并没有使用单例框架中的做法将他放在pirvice中，而是创造性的放到了一个方法中，这个方法是staic的，所以整篇项目有且仅有一个该线程  </p><p>Linux 环境下， 配置gpio仅需访问对应的接口即可，而且是直接调用shell就可以实现，头一次接触， 觉得有种力大砖飞的美，总觉得不最起用个通道？🤔</p><p>是我愚昧了，只用在定义的时候要力大砖飞， 修改的时候老老实实要用文件读写</p><h2 id="serial串口线程"><a href="#serial串口线程" class="headerlink" title="serial串口线程"></a>serial串口线程</h2><blockquote><p>没有接触过Linux跑串口，尝尝佬的咸淡</p></blockquote><p>它将与 打印机通讯 与 其外设的通讯 分开为成为两个类</p><h3 id="串口通讯"><a href="#串口通讯" class="headerlink" title="串口通讯"></a>串口通讯</h3><ul><li>细数了其串口通讯外设：<ol><li>纵向横梁电机</li><li>横向横梁电机</li><li>限位保护器 * 4</li><li>（未知传感器）* 4</li></ol></li></ul><blockquote><p> 我一定是瞧见了新的一种创建进程的方法</p></blockquote><ul><li>新的技巧它使用了 <strong>符号重载</strong> 将&lt;&lt;重载出了push_back的用法 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++">QStringList m_serialPortName;<br>  foreach(<span class="hljs-type">const</span> QSerialPortInfo &amp;info,QSerialPortInfo::<span class="hljs-built_in">availablePorts</span>())&#123;<br>      m_serialPortName &lt;&lt; info.<span class="hljs-built_in">portName</span>();<br>  &#125;<br></code></pre></td></tr></table></figure>但是他没用到这个方法，他直接固定名为ttyS2的串口!精彩！</li></ul><p>它使用了一个新的类用于存放读到的数据，返回数据blablablabla这样的东西，这个类的信号函数和槽函数极多，主要用来收发。</p><blockquote><p>是的没错， 它使用了第二种创建进程的方法，以QObject的子类转移到 Thread 的进程中</p></blockquote><p>使用了心跳函数确保子进程能及时处死（莫名残忍）</p><h3 id="打印机通讯"><a href="#打印机通讯" class="headerlink" title="打印机通讯"></a>打印机通讯</h3><blockquote><p>下次一定</p></blockquote><h2 id="防不结款模块"><a href="#防不结款模块" class="headerlink" title="防不结款模块"></a>防不结款模块</h2><p>序列号全部定义在主函数中，常量定义，内存常量区中一定有他的配置结果， 如果修改就可以破解。（网络安全狂喜</p><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><blockquote><p>顺完这个我就打卡下班</p></blockquote><p>为了使标定好的值断电后仍然存在，于是使用数据库来存储标定好的数据</p><p>于是，当上电完成之后 就对 disMeterwhere 这个 哈希表 进行同步，使用的手法也是相当精简，一步到位</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-built_in">findCurrentData</span>(disMeterCalDBName,disMeterwhere[i],&amp;disMeterrow,disMeterCalFieldName_list.<span class="hljs-built_in">size</span>())<br></code></pre></td></tr></table></figure><p>至于声明这个函数的database项目，<strong>下次一定</strong></p><h2 id="初始数据iniAll"><a href="#初始数据iniAll" class="headerlink" title="初始数据iniAll"></a>初始数据iniAll</h2><p>将实验需要进行的模式取值进行一个定义，其中包含：</p><blockquote><p>请等一下，这些所有的配置都不计入数据库，BUT，他计入了ini文件，也可以掉电不丢失</p></blockquote><ul><li>PID数据</li><li>标定数据</li><li>脉冲系数</li><li>最大速度保护</li><li>电机类型</li><li>步进频率</li></ul><p>然后忙里偷闲将 ： 电机类型  步进频率 进行了一个串口通讯放出</p><ul><li>脉冲是否取反</li><li>电机是否取反</li><li>力值取反</li><li>点击开始是否全部清零</li><li>位移来源选择</li><li>位移计编号</li><li>变形来源选择</li><li>力值&#x2F;位移单位</li><li>传感器编号</li><li>传感器量程</li><li>力值过载保护百分比</li><li>力值过载保护</li><li>速度是否一致</li><li>按钮操作</li><li>外接按钮控制</li><li>标定力值</li><li>坐标轴初始值范围</li><li>横梁加力方向</li><li>力值小数点位数</li><li>位移小数点位数</li><li>加减速时间</li></ul><p>所以Pc程序的上任工程师将这些数据放入了：数据库中一并封存 </p><h2 id="语言选择"><a href="#语言选择" class="headerlink" title="语言选择"></a>语言选择</h2><blockquote><p>显示后直接隐藏，然后又delete了，估计还没加。</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>QT</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用 Qt-material-widget 美化项目</title>
    <link href="/2024/06/28/qt%E7%BE%8E%E5%8C%96/"/>
    <url>/2024/06/28/qt%E7%BE%8E%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h1 id="Qt-material-widget"><a href="#Qt-material-widget" class="headerlink" title="Qt-material-widget"></a>Qt-material-widget</h1><br>今天收到了sir 的催促消息，我需要迅速做一版demo让sir看看怎么个事<p>于是我找了一份佬的控件库 <a href="https://github.com/laserpants/qt-material-widgets" title="Github连接">肘去看看</a></p><h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><p>废话不多， 今天火急火燎的找了一个佬做的widget类，感觉蛮不错，很多东西都是用的Android默认的动画，本来这东西在Andrioid上只能说狗看了狗都嫌，但是放到我们桌面开发QT这里，仿佛就是 <strong>致命的解药</strong></p><h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><p>相当多，举几个比较有存在感的例子</p><ul><li>Toggle 开关</li><li>Tabs 任务栏</li><li>Slider 线性开关</li><li>Circular Progress 加载转转</li><li>Snackbar 弹出提醒框</li><li>Drawer 弹出菜单</li><li>dialog 弹出页面</li></ul><p><strong>啊，美妙！</strong></p><h2 id="移植"><a href="#移植" class="headerlink" title="移植"></a>移植</h2><p>我要把这东西改到我想让他出现的地方<br>大致看了看用法作用， 如果想让他实现的话，需要一段时间和一定的熟练度</p>]]></content>
    
    
    
    <tags>
      
      <tag>QT</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>QT项目经手解析Ⅰ</title>
    <link href="/2024/06/27/%E5%8F%B2%E5%B1%B1%E8%A7%A3%E6%9E%901/"/>
    <url>/2024/06/27/%E5%8F%B2%E5%B1%B1%E8%A7%A3%E6%9E%901/</url>
    
    <content type="html"><![CDATA[<h1 id="MF-TEST-工程Ⅰ"><a href="#MF-TEST-工程Ⅰ" class="headerlink" title="MF-TEST 工程Ⅰ"></a>MF-TEST 工程Ⅰ</h1><br><h2 id="MAIN-主函数入口"><a href="#MAIN-主函数入口" class="headerlink" title="MAIN 主函数入口"></a>MAIN 主函数入口</h2><ul><li>数据库创建</li><li>数据库初始值存入</li><li>传感器初始值</li><li>阶段初始化</li><li>运行预加载界面</li></ul><h2 id="perloadPage-预加载类"><a href="#perloadPage-预加载类" class="headerlink" title="perloadPage 预加载类"></a>perloadPage 预加载类</h2><ul><li>寻找串口连接（貌似存在默认连接COM1）</li><li>建立主界面 Maininterface ⭐</li><li>如果不存在串口：<ul><li>调控所有的主界面显示 调用槽 执行 主界面：串口错误模式</li></ul></li><li>如果存在：<ul><li>显示正在配置串口 设置槽 轮值至串口信息匹配 如果没有匹配成功 则进入主菜单， 执行串口模式错误</li></ul></li></ul><h2 id="MainEle-主界面类"><a href="#MainEle-主界面类" class="headerlink" title="MainEle 主界面类"></a>MainEle 主界面类</h2><ul><li>设置 主页面：左侧、上侧菜单栏</li><li>设置 实验数据显示</li><li>设置 实验类型菜单</li><li>设置 实验类型名字</li><li>设置 定时器</li><li>添加实验类型 清单 支持选择<ul><li>根据选择适配 实验设置界面 、 全部清零信号 、 新建报表 、 新建查询表 、新建word表</li><li>启用 MetalStretchingtest （主页面置中）类 ⭐</li></ul></li><li>TeststackedWidget 子内容 框类</li><li>Pageswitchingfunction 按钮按下页面更改：<ul><li>所有要求 激活 password 界面（输入密码）</li><li>设置：<ul><li>setset 类 （保存与取消的 系统设置）</li><li>貌似使用了一种 内联函数式的 connect</li></ul></li><li>标定：<ul><li>启动 eleCalibtion（标定） 界面 ⭐</li></ul></li><li>实验类型选择：<ul><li>添加 addtest 实验类型界面</li></ul></li><li>权限界面<ul><li>Permission界面 通讯设置和注册页面</li></ul></li><li>工具箱界面<ul><li>m_toolbox 千分表通讯设置</li></ul></li></ul></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>QT</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>触摸屏 在QT开发中的位置</title>
    <link href="/2024/06/25/QT%E8%A7%A6%E6%91%B8%E5%B1%8F1/"/>
    <url>/2024/06/25/QT%E8%A7%A6%E6%91%B8%E5%B1%8F1/</url>
    
    <content type="html"><![CDATA[<h1 id="触摸屏-在QT开发中的位置"><a href="#触摸屏-在QT开发中的位置" class="headerlink" title="触摸屏 在QT开发中的位置"></a>触摸屏 在QT开发中的位置</h1><br><h2 id="首先需要了解一下什么是事件"><a href="#首先需要了解一下什么是事件" class="headerlink" title="首先需要了解一下什么是事件"></a>首先需要了解一下什么是事件</h2><ul><li>我理解的事件是MCU的中断，即发生事件立即去执行处理事件的相关方法<ul><li>只不过是否中断主函数执行呢？我觉得应该不影响<br></li></ul></li><li>只需要重新在子类中继承某些事件的处理方法，则可以重写这些方法</li><li>所有事件需要收到类的事件转发器才会进行响应，该事件转发器名为event()</li><li>在进入事件转发器之前会进入事件过滤器 eventFilterd() 可用于过滤不想使用的事件 (return true)</li></ul><h2 id="QTouchEvent-类"><a href="#QTouchEvent-类" class="headerlink" title="QTouchEvent 类"></a>QTouchEvent 类</h2><ul><li>这个类主要是负责处理触摸事件的、但是看了一部分大佬的代码也有直接用鼠标实现功能的</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>QT</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
